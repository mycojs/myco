use crate::errors::MycoError;
use crate::manifest::{myco_local::MycoLocalToml, MycoToml};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Serialize, Deserialize)]
struct TSConfig {
    #[serde(rename = "compilerOptions")]
    compiler_options: CompilerOptions,
    include: Vec<String>,
}

#[derive(Serialize, Deserialize)]
struct CompilerOptions {
    target: String,
    module: String,
    #[serde(rename = "noImplicitAny")]
    no_implicit_any: bool,
    #[serde(rename = "removeComments")]
    remove_comments: bool,
    #[serde(rename = "preserveConstEnums")]
    preserve_const_enums: bool,
    #[serde(rename = "sourceMap")]
    source_map: bool,
    lib: Vec<String>,
    strict: bool,
    #[serde(rename = "noEmit")]
    no_emit: bool,
    #[serde(rename = "moduleResolution")]
    module_resolution: String,
    #[serde(rename = "allowImportingTsExtensions")]
    allow_importing_ts_extensions: bool,
    paths: HashMap<String, Vec<String>>,
}

impl Default for TSConfig {
    fn default() -> Self {
        let mut paths = HashMap::new();
        paths.insert("vendor/*".to_string(), vec!["./vendor/*".to_string()]);

        TSConfig {
            compiler_options: CompilerOptions {
                target: "es2022".to_string(),
                module: "NodeNext".to_string(),
                no_implicit_any: true,
                remove_comments: true,
                preserve_const_enums: true,
                source_map: true,
                lib: vec!["esnext".to_string()],
                strict: true,
                no_emit: true,
                module_resolution: "NodeNext".to_string(),
                allow_importing_ts_extensions: true,
                paths,
            },
            include: vec!["./.myco/myco.d.ts".to_string()],
        }
    }
}

/// Generate tsconfig.json content based on myco.toml configuration
pub fn generate_tsconfig_json(myco_toml: &MycoToml) -> Result<String, MycoError> {
    let mut tsconfig = TSConfig::default();

    // Override include paths if specified in myco.toml
    if let Some(package) = &myco_toml.package {
        if let Some(include_config) = &package.include {
            let mut all_includes = Vec::new();

            // Add dev includes if specified
            if let Some(dev_includes) = &include_config.dev {
                all_includes.extend(
                    dev_includes
                        .iter()
                        .map(|folder| format!("{}/**/*.ts", folder.trim_end_matches('/'))),
                );
            }

            // Add prod includes if specified
            if let Some(prod_includes) = &include_config.prod {
                all_includes.extend(
                    prod_includes
                        .iter()
                        .map(|folder| format!("{}/**/*.ts", folder.trim_end_matches('/'))),
                );
            }

            // If we have any includes, use them
            if !all_includes.is_empty() {
                tsconfig.include = all_includes;
                // Always ensure .myco/myco.d.ts is included
                if !tsconfig.include.contains(&"./.myco/myco.d.ts".to_string()) {
                    tsconfig.include.push("./.myco/myco.d.ts".to_string());
                }
            }
        }
    }

    // Check for workspace dependencies in myco-local.toml and add path mappings
    if let Ok(local_toml) = MycoLocalToml::load_from_myco_toml_path(std::path::PathBuf::from(".")) {
        let workspace_paths = local_toml.clone_resolve();
        if !workspace_paths.is_empty() {
            // Add workspace path mappings to the default paths
            for (package_name, resolve_paths) in workspace_paths {
                if let Some(first_path) = resolve_paths.first() {
                    // Add path mapping for the package
                    tsconfig
                        .compiler_options
                        .paths
                        .insert(package_name.clone(), vec![format!("{}/src", first_path)]);

                    // Also add wildcard mapping for submodules
                    tsconfig.compiler_options.paths.insert(
                        format!("{}/*", package_name),
                        vec![format!("{}/src/*", first_path)],
                    );
                }
            }
        }
    }

    // Convert TSConfig to JSON Value for manipulation
    let mut tsconfig_value =
        serde_json::to_value(&tsconfig).map_err(|e| MycoError::JsonSerialize { source: e })?;

    // Apply arbitrary tsconfig overrides from myco.toml
    if let Some(overrides) = &myco_toml.tsconfig {
        merge_json_values(&mut tsconfig_value, overrides);
    }

    let tsconfig_content = format!(
        "// This file was generated by Myco. Do not edit it directly.\n{}",
        serde_json::to_string_pretty(&tsconfig_value)
            .map_err(|e| MycoError::JsonSerialize { source: e })?
    );

    Ok(tsconfig_content)
}

/// Recursively merge JSON values, with the override values taking precedence
fn merge_json_values(
    target: &mut serde_json::Value,
    overrides: &std::collections::BTreeMap<String, serde_json::Value>,
) {
    if let serde_json::Value::Object(target_map) = target {
        for (key, value) in overrides {
            if let serde_json::Value::Object(override_obj) = value {
                // If the override value is an object, we need to merge it
                if target_map.contains_key(key) {
                    if let Some(existing_value) = target_map.get_mut(key) {
                        if let serde_json::Value::Object(_) = existing_value {
                            // Recursively merge the nested objects
                            let override_map: std::collections::BTreeMap<
                                String,
                                serde_json::Value,
                            > = override_obj
                                .iter()
                                .map(|(k, v)| (k.clone(), v.clone()))
                                .collect();
                            merge_json_values(existing_value, &override_map);
                        } else {
                            // Target exists but is not an object, replace it
                            *existing_value = value.clone();
                        }
                    }
                } else {
                    // Target doesn't have this key, so just insert the override
                    target_map.insert(key.clone(), value.clone());
                }
            } else {
                // Override value is not an object, so just replace/insert it
                target_map.insert(key.clone(), value.clone());
            }
        }
    }
}
