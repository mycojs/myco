use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use crate::manifest::MycoToml;
use crate::errors::MycoError;

#[derive(Serialize, Deserialize)]
struct TSConfig {
    #[serde(rename = "compilerOptions")]
    compiler_options: CompilerOptions,
    include: Vec<String>,
}

#[derive(Serialize, Deserialize)]
struct CompilerOptions {
    target: String,
    module: String,
    #[serde(rename = "noImplicitAny")]
    no_implicit_any: bool,
    #[serde(rename = "removeComments")]
    remove_comments: bool,
    #[serde(rename = "preserveConstEnums")]
    preserve_const_enums: bool,
    #[serde(rename = "sourceMap")]
    source_map: bool,
    lib: Vec<String>,
    strict: bool,
    #[serde(rename = "noEmit")]
    no_emit: bool,
    #[serde(rename = "moduleResolution")]
    module_resolution: String,
    #[serde(rename = "allowImportingTsExtensions")]
    allow_importing_ts_extensions: bool,
    paths: HashMap<String, Vec<String>>,
}

impl Default for TSConfig {
    fn default() -> Self {
        let mut paths = HashMap::new();
        paths.insert("vendor/*".to_string(), vec!["./vendor/*".to_string()]);

        TSConfig {
            compiler_options: CompilerOptions {
                target: "es2022".to_string(),
                module: "NodeNext".to_string(),
                no_implicit_any: true,
                remove_comments: true,
                preserve_const_enums: true,
                source_map: true,
                lib: vec!["esnext".to_string()],
                strict: true,
                no_emit: true,
                module_resolution: "NodeNext".to_string(),
                allow_importing_ts_extensions: true,
                paths,
            },
            include: vec![
                "src/**/*.ts".to_string(),
                "test/**/*.ts".to_string(),
                "./.myco/myco.d.ts".to_string(),
            ],
        }
    }
}

/// Generate tsconfig.json content based on myco.toml configuration
pub fn generate_tsconfig_json(myco_toml: &MycoToml) -> Result<String, MycoError> {
    let mut tsconfig = TSConfig::default();
    
    // Override include paths if specified in myco.toml
    if let Some(package) = &myco_toml.package {
        if let Some(include_paths) = &package.include {
            // Start with user-defined include paths
            tsconfig.include = include_paths.clone();
            // Always ensure .myco/myco.d.ts is included
            if !tsconfig.include.contains(&"./.myco/myco.d.ts".to_string()) {
                tsconfig.include.push("./.myco/myco.d.ts".to_string());
            }
        }
    }

    let tsconfig_content = format!(
        "// This file was generated by Myco. Do not edit it directly.\n{}",
        serde_json::to_string_pretty(&tsconfig)
            .map_err(|e| MycoError::JsonSerialize { source: e })?
    );
    
    Ok(tsconfig_content)
} 